commit cb464bd29e11d241bf0aba49c1a9e480cf7cd1a6
Author: Matt Pocock <mattpocockvoice@gmail.com>
Date:   Fri Oct 31 16:03:47 2025 +0000

    04.04.02 Added includeThread

diff --git a/src/app/api/chat/get-emails-tool.ts b/src/app/api/chat/get-emails-tool.ts
index 266dd47..6ab914b 100644
--- a/src/app/api/chat/get-emails-tool.ts
+++ b/src/app/api/chat/get-emails-tool.ts
@@ -4,34 +4,51 @@ import { z } from "zod";
 
 export const getEmailsTool = tool({
   description:
-    "Fetch full content of specific emails by their IDs. Use this after searching/filtering to retrieve complete email bodies.",
+    "Fetch full content of specific emails by their IDs. Use this after searching/filtering to retrieve complete email bodies. Optionally include entire conversation threads.",
   inputSchema: z.object({
     ids: z
       .array(z.string())
       .describe("Array of email IDs to retrieve full content for"),
+    includeThread: z
+      .boolean()
+      .describe(
+        "If true, fetch entire conversation threads for the specified emails"
+      )
+      .default(false),
   }),
-  execute: async ({ ids }) => {
-    console.log("Get emails params:", { ids });
+  execute: async ({ ids, includeThread }) => {
+    console.log("Get emails params:", { ids, includeThread });
 
     const emails = await loadEmails();
 
-    const results = emails.filter((email) => ids.includes(email.id));
+    let results = emails.filter((email) => ids.includes(email.id));
+
+    if (includeThread && results.length > 0) {
+      // Get all unique threadIds from the requested emails
+      const threadIds = [...new Set(results.map((email) => email.threadId))];
+
+      // Get all emails that belong to these threads
+      results = emails.filter((email) => threadIds.includes(email.threadId));
+
+      // Sort by timestamp to maintain conversation order
+      results.sort((a, b) => a.timestamp.localeCompare(b.timestamp));
+    }
 
     console.log(`Returning ${results.length} emails`);
 
     return {
       emails: results.map((email) => ({
         id: email.id,
         threadId: email.threadId,
         subject: email.subject,
         from: email.from,
         to: email.to,
         timestamp: email.timestamp,
         body: email.body,
         cc: email.cc,
         inReplyTo: email.inReplyTo,
         references: email.references,
       })),
     };
   },
 });
diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index 5c32021..e7822a1 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -105,43 +105,45 @@ export async function POST(req: Request) {
       const result = streamText({
         model: google("gemini-2.5-flash"),
         messages: convertToModelMessages(messages),
         system: `
 <task-context>
 You are an email assistant that helps users find and understand information from their emails.
 </task-context>
 
 <rules>
 - You have THREE tools available: 'search', 'filterEmails', and 'getEmails'
 - Follow this multi-step workflow for token efficiency:
 
   STEP 1 - Browse metadata:
   USE 'filterEmails' when the user wants to:
   - Find emails from/to specific people (e.g., "emails from John", "emails to sarah@example.com")
   - Filter by date ranges (e.g., "emails before January 2024", "emails after last week")
   - Find emails containing exact text (e.g., "emails containing 'invoice'")
   - Any combination of precise filtering criteria
 
   USE 'search' when the user wants to:
   - Find information semantically (e.g., "emails about the project deadline")
   - Search by concepts or topics (e.g., "discussions about budget")
   - Find answers to questions (e.g., "what did John say about the meeting?")
   - Any query requiring understanding of meaning/context
   - Find people by name or description (e.g., "Mike's biggest client")
 
   NOTE: 'search' and 'filterEmails' return metadata with snippets only (id, threadId, subject, from, to, timestamp, snippet)
 
   STEP 2 - Review and select:
   - Review the subjects, metadata, and snippets from search/filter results
   - Identify which specific emails need full content to answer the user's question
   - If snippets contain enough info, answer directly without fetching full content
 
   STEP 3 - Fetch full content:
   USE 'getEmails' to retrieve full email bodies:
   - Pass array of email IDs you need to read completely
+  - Set includeThread=true if you need conversation context (replies, full thread)
+  - Set includeThread=false for individual emails
 
 - NEVER answer from your training data - always use tools first
 - If the first query doesn't find enough information, try different approaches or tools
 - Only after using tools should you formulate your answer based on the results
 </rules>
 
 <the-ask>
diff --git a/src/app/chat.tsx b/src/app/chat.tsx
index 9e2dc08..5beb90d 100644
--- a/src/app/chat.tsx
+++ b/src/app/chat.tsx
@@ -49,384 +49,390 @@ import { Button } from "@/components/ui/button";
 export const Chat = (props: { chat: DB.Chat | null }) => {
   const [backupChatId, setBackupChatId] = useState(crypto.randomUUID());
   const [input, setInput] = useState("");
   const searchParams = useSearchParams();
   const router = useRouter();
   const chatIdFromSearchParams = searchParams.get("chatId");
 
   const chatIdInUse = chatIdFromSearchParams || backupChatId;
   const { messages, sendMessage, status, regenerate } = useChat<MyMessage>({
     id: chatIdInUse,
     messages: props.chat?.messages || [],
     onData: (message) => {
       if (
         message.type === "data-frontend-action" &&
         message.data === "refresh-sidebar"
       ) {
         router.refresh();
       }
     },
     generateId: () => crypto.randomUUID(),
   });
 
   const ref = useFocusWhenNoChatIdPresent(chatIdFromSearchParams);
 
   const handleSubmit = (message: PromptInputMessage) => {
     const hasText = Boolean(message.text);
     const hasAttachments = Boolean(message.files?.length);
 
     if (!(hasText || hasAttachments)) {
       return;
     }
 
     startTransition(() => {
       sendMessage(
         {
           text: message.text || "Sent with attachments",
           files: message.files,
         },
         {
           body: {
             id: chatIdInUse,
           },
         }
       );
 
       setInput("");
 
       if (!chatIdFromSearchParams) {
         router.push(`/?chatId=${chatIdInUse}`);
         setBackupChatId(crypto.randomUUID());
       }
     });
   };
   return (
     <div className="relative flex-1 items-center flex flex-col min-h-0 w-full">
       <Conversation className="w-full">
         <ConversationContent className="max-w-4xl mx-auto w-full pb-40">
           {messages.map((message) => (
             <div key={message.id}>
               {message.role === "assistant" &&
                 message.parts.filter((part) => part.type === "source-url")
                   .length > 0 && (
                   <Sources>
                     <SourcesTrigger
                       count={
                         message.parts.filter(
                           (part) => part.type === "source-url"
                         ).length
                       }
                     />
                     {message.parts
                       .filter((part) => part.type === "source-url")
                       .map((part, i) => (
                         <SourcesContent key={`${message.id}-${i}`}>
                           <Source
                             key={`${message.id}-${i}`}
                             href={part.url}
                             title={part.url}
                           />
                         </SourcesContent>
                       ))}
                   </Sources>
                 )}
               {message.parts.map((part, i) => {
                 switch (part.type) {
                   case "text":
                     return (
                       <Fragment key={`${message.id}-${i}`}>
                         <Message from={message.role}>
                           <MessageContent>
                             <Response>{part.text}</Response>
                           </MessageContent>
                         </Message>
                         {message.role === "assistant" &&
                           i === messages.length - 1 && (
                             <Actions className="mt-2">
                               <Action
                                 onClick={() => regenerate()}
                                 label="Retry"
                               >
                                 <RefreshCcwIcon className="size-3" />
                               </Action>
                               <Action
                                 onClick={() =>
                                   navigator.clipboard.writeText(part.text)
                                 }
                                 label="Copy"
                               >
                                 <CopyIcon className="size-3" />
                               </Action>
                             </Actions>
                           )}
                       </Fragment>
                     );
                   case "reasoning":
                     return (
                       <Reasoning
                         key={`${message.id}-${i}`}
                         className="w-full"
                         isStreaming={
                           status === "streaming" &&
                           i === message.parts.length - 1 &&
                           message.id === messages.at(-1)?.id
                         }
                       >
                         <ReasoningTrigger />
                         <ReasoningContent>{part.text}</ReasoningContent>
                       </Reasoning>
                     );
                   case "tool-search":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={false}
                       >
                         <ToolHeader
                           title="Search"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Parameters
                                 </h4>
                                 <div className="text-sm">
                                   {part.input.keywords && (
                                     <div>
                                       <span className="font-medium">
                                         Keywords:
                                       </span>{" "}
                                       {part.input.keywords.join(", ")}
                                     </div>
                                   )}
                                   {part.input.searchQuery && (
                                     <div>
                                       <span className="font-medium">
                                         Search Query:
                                       </span>{" "}
                                       {part.input.searchQuery}
                                     </div>
                                   )}
                                 </div>
                               </div>
                             )}
 
                             {/* Email results */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <EmailResultsGrid emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   case "tool-filterEmails":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={false}
                       >
                         <ToolHeader
                           title="Filter Emails"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Filters
                                 </h4>
                                 <div className="text-sm space-y-1">
                                   {part.input.from && (
                                     <div>
                                       <span className="font-medium">From:</span>{" "}
                                       {part.input.from}
                                     </div>
                                   )}
                                   {part.input.to && (
                                     <div>
                                       <span className="font-medium">To:</span>{" "}
                                       {part.input.to}
                                     </div>
                                   )}
                                   {part.input.contains && (
                                     <div>
                                       <span className="font-medium">
                                         Contains:
                                       </span>{" "}
                                       {part.input.contains}
                                     </div>
                                   )}
                                   {part.input.before && (
                                     <div>
                                       <span className="font-medium">
                                         Before:
                                       </span>{" "}
                                       {new Date(
                                         part.input.before
                                       ).toLocaleString()}
                                     </div>
                                   )}
                                   {part.input.after && (
                                     <div>
                                       <span className="font-medium">
                                         After:
                                       </span>{" "}
                                       {new Date(
                                         part.input.after
                                       ).toLocaleString()}
                                     </div>
                                   )}
                                   {part.input.limit && (
                                     <div>
                                       <span className="font-medium">
                                         Limit:
                                       </span>{" "}
                                       {part.input.limit}
                                     </div>
                                   )}
                                 </div>
                               </div>
                             )}
 
                             {/* Email results */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <EmailResultsGrid emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   case "tool-getEmails":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={true}
                       >
                         <ToolHeader
                           title="Get Emails"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Parameters
                                 </h4>
                                 <div className="text-sm space-y-1">
                                   {part.input.ids && (
                                     <div>
                                       <span className="font-medium">
                                         Email IDs:
                                       </span>{" "}
                                       {part.input.ids.length} email
                                       {part.input.ids.length !== 1 ? "s" : ""}
                                     </div>
                                   )}
+                                  <div>
+                                    <span className="font-medium">
+                                      Include Thread:
+                                    </span>{" "}
+                                    {part.input.includeThread ? "Yes" : "No"}
+                                  </div>
                                 </div>
                               </div>
                             )}
 
                             {/* Full email content */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <FullEmailDisplay emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   default:
                     return null;
                 }
               })}
             </div>
           ))}
           {status === "submitted" && <Loader />}
         </ConversationContent>
         <ConversationScrollButton />
       </Conversation>
       <div className="absolute bottom-0 flex items-center justify-center w-full sm:px-6 px-5">
         <PromptInput
           onSubmit={handleSubmit}
           className="mb-4"
           globalDrop
           multiple
         >
           <PromptInputBody>
             <PromptInputAttachments>
               {(attachment) => <PromptInputAttachment data={attachment} />}
             </PromptInputAttachments>
             <PromptInputTextarea
               onChange={(e) => setInput(e.target.value)}
               value={input}
               ref={ref}
               autoFocus
             />
           </PromptInputBody>
           <PromptInputToolbar>
             <PromptInputTools>
               <PromptInputActionMenu>
                 <PromptInputActionMenuTrigger />
                 <PromptInputActionMenuContent>
                   <PromptInputActionAddAttachments />
                 </PromptInputActionMenuContent>
               </PromptInputActionMenu>
             </PromptInputTools>
             <PromptInputSubmit disabled={!input && !status} status={status} />
           </PromptInputToolbar>
         </PromptInput>
       </div>
     </div>
   );
 };
