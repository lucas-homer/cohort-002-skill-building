commit f258fc04d61d757301b5559b3aaa073d269dcd80
Author: Matt Pocock <mattpocockvoice@gmail.com>
Date:   Fri Oct 31 16:02:47 2025 +0000

    04.04.01 Made searches provide only metadata, with getting full emails in a separate tool

diff --git a/src/app/api/chat/filter-tool.ts b/src/app/api/chat/filter-tool.ts
index 032ca27..9509a70 100644
--- a/src/app/api/chat/filter-tool.ts
+++ b/src/app/api/chat/filter-tool.ts
@@ -4,97 +4,102 @@ import { z } from "zod";
 
 export const filterEmailsTool = tool({
   description:
-    "Filter emails by exact criteria like sender, recipient, date range, or text content. Use this for precise filtering (e.g., 'emails from John', 'emails before 2024-01-01', 'emails containing invoice').",
+    "Filter emails by exact criteria like sender, recipient, date range, or text content. Returns metadata with snippets only - use getEmails tool to fetch full content of specific emails.",
   inputSchema: z.object({
     from: z
       .string()
       .describe("Filter by sender email/name (partial match, case-insensitive)")
       .optional(),
     to: z
       .string()
       .describe(
         "Filter by recipient email/name (partial match, case-insensitive)"
       )
       .optional(),
     contains: z
       .string()
       .describe(
         "Filter by text in subject or body (partial match, case-insensitive)"
       )
       .optional(),
     before: z
       .string()
       .describe(
         "Filter emails before this ISO 8601 timestamp (e.g., '2024-01-01T00:00:00Z')"
       )
       .optional(),
     after: z
       .string()
       .describe(
         "Filter emails after this ISO 8601 timestamp (e.g., '2024-01-01T00:00:00Z')"
       )
       .optional(),
     limit: z
       .number()
       .describe("Maximum number of results to return")
       .default(10),
   }),
   execute: async ({ from, to, contains, before, after, limit }) => {
     console.log("Filter params:", { from, to, contains, before, after, limit });
 
     const emails = await loadEmails();
 
     // Apply filters
     let filtered = emails;
 
     if (from) {
       const lowerFrom = from.toLowerCase();
       filtered = filtered.filter((email) =>
         email.from.toLowerCase().includes(lowerFrom)
       );
     }
 
     if (to) {
       const lowerTo = to.toLowerCase();
       filtered = filtered.filter((email) => {
         const toStr = Array.isArray(email.to) ? email.to.join(" ") : email.to;
         return toStr.toLowerCase().includes(lowerTo);
       });
     }
 
     if (contains) {
       const lowerContains = contains.toLowerCase();
       filtered = filtered.filter(
         (email) =>
           email.subject.toLowerCase().includes(lowerContains) ||
           email.body.toLowerCase().includes(lowerContains)
       );
     }
 
     if (before) {
       filtered = filtered.filter((email) => email.timestamp < before);
     }
 
     if (after) {
       filtered = filtered.filter((email) => email.timestamp > after);
     }
 
     // Apply limit
     const results = filtered.slice(0, limit);
 
     console.log(
       `Filtered ${filtered.length} emails, returning ${results.length}`
     );
 
     return {
-      emails: results.map((email) => ({
-        id: email.id,
-        subject: email.subject,
-        body: email.body,
-        from: email.from,
-        to: email.to,
-        timestamp: email.timestamp,
-      })),
+      emails: results.map((email) => {
+        const snippet = email.body.slice(0, 150).trim() + (email.body.length > 150 ? "..." : "");
+
+        return {
+          id: email.id,
+          threadId: email.threadId,
+          subject: email.subject,
+          from: email.from,
+          to: email.to,
+          timestamp: email.timestamp,
+          snippet,
+        };
+      }),
     };
   },
 });
diff --git a/src/app/api/chat/get-emails-tool.ts b/src/app/api/chat/get-emails-tool.ts
new file mode 100644
index 0000000..266dd47
--- /dev/null
+++ b/src/app/api/chat/get-emails-tool.ts
@@ -0,0 +1,37 @@
+import { loadEmails } from "@/app/search";
+import { tool } from "ai";
+import { z } from "zod";
+
+export const getEmailsTool = tool({
+  description:
+    "Fetch full content of specific emails by their IDs. Use this after searching/filtering to retrieve complete email bodies.",
+  inputSchema: z.object({
+    ids: z
+      .array(z.string())
+      .describe("Array of email IDs to retrieve full content for"),
+  }),
+  execute: async ({ ids }) => {
+    console.log("Get emails params:", { ids });
+
+    const emails = await loadEmails();
+
+    const results = emails.filter((email) => ids.includes(email.id));
+
+    console.log(`Returning ${results.length} emails`);
+
+    return {
+      emails: results.map((email) => ({
+        id: email.id,
+        threadId: email.threadId,
+        subject: email.subject,
+        from: email.from,
+        to: email.to,
+        timestamp: email.timestamp,
+        body: email.body,
+        cc: email.cc,
+        inReplyTo: email.inReplyTo,
+        references: email.references,
+      })),
+    };
+  },
+});
diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index 4c05f70..5c32021 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -19,6 +19,7 @@ import {
 import { generateTitleForChat } from "./generate-title";
 import { searchTool } from "./search-tool";
 import { filterEmailsTool } from "./filter-tool";
+import { getEmailsTool } from "./get-emails-tool";
 
 // Allow streaming responses up to 30 seconds
 export const maxDuration = 30;
@@ -34,6 +35,7 @@ export type MyMessage = UIMessage<
 const getTools = (messages: UIMessage[]) => ({
   search: searchTool(messages),
   filterEmails: filterEmailsTool,
+  getEmails: getEmailsTool,
 });
 
 export async function POST(req: Request) {
@@ -103,58 +105,70 @@ export async function POST(req: Request) {
       const result = streamText({
         model: google("gemini-2.5-flash"),
         messages: convertToModelMessages(messages),
         system: `
 <task-context>
 You are an email assistant that helps users find and understand information from their emails.
 </task-context>
 
 <rules>
-- You have TWO tools available: 'search' and 'filterEmails'
-- Choose the appropriate tool based on the query type:
+- You have THREE tools available: 'search', 'filterEmails', and 'getEmails'
+- Follow this multi-step workflow for token efficiency:
 
+  STEP 1 - Browse metadata:
   USE 'filterEmails' when the user wants to:
   - Find emails from/to specific people (e.g., "emails from John", "emails to sarah@example.com")
   - Filter by date ranges (e.g., "emails before January 2024", "emails after last week")
   - Find emails containing exact text (e.g., "emails containing 'invoice'")
   - Any combination of precise filtering criteria
 
   USE 'search' when the user wants to:
   - Find information semantically (e.g., "emails about the project deadline")
   - Search by concepts or topics (e.g., "discussions about budget")
   - Find answers to questions (e.g., "what did John say about the meeting?")
   - Any query requiring understanding of meaning/context
   - Find people by name or description (e.g., "Mike's biggest client")
 
+  NOTE: 'search' and 'filterEmails' return metadata with snippets only (id, threadId, subject, from, to, timestamp, snippet)
+
+  STEP 2 - Review and select:
+  - Review the subjects, metadata, and snippets from search/filter results
+  - Identify which specific emails need full content to answer the user's question
+  - If snippets contain enough info, answer directly without fetching full content
+
+  STEP 3 - Fetch full content:
+  USE 'getEmails' to retrieve full email bodies:
+  - Pass array of email IDs you need to read completely
+
 - NEVER answer from your training data - always use tools first
 - If the first query doesn't find enough information, try different approaches or tools
 - Only after using tools should you formulate your answer based on the results
 </rules>
 
 <the-ask>
-Here is the user's question. Use the appropriate tool(s) first, then provide your answer based on what you find.
+Here is the user's question. Follow the multi-step workflow above to efficiently find and retrieve the information.
 </the-ask>
         `,
         tools: getTools(messages),
         stopWhen: [stepCountIs(10)],
       });
 
       writer.merge(
         result.toUIMessageStream({
           sendSources: true,
           sendReasoning: true,
         })
       );
 
       await generateTitlePromise;
     },
     generateId: () => crypto.randomUUID(),
     onFinish: async ({ responseMessage }) => {
       await appendToChatMessages(chatId, [responseMessage]);
     },
   });
 
   // send sources and reasoning back to the client
   return createUIMessageStreamResponse({
     stream,
   });
 }
diff --git a/src/app/api/chat/search-tool.ts b/src/app/api/chat/search-tool.ts
index d12d0c0..1240687 100644
--- a/src/app/api/chat/search-tool.ts
+++ b/src/app/api/chat/search-tool.ts
@@ -14,70 +14,78 @@ const NUMBER_PASSED_TO_RERANKER = 30;
 export const searchTool = (messages: UIMessage[]) =>
   tool({
     description:
-      "Search emails using both keyword and semantic search. Returns most relevant emails ranked by reciprocal rank fusion.",
+      "Search emails using both keyword and semantic search. Returns metadata with snippets only - use getEmails tool to fetch full content of specific emails.",
     inputSchema: z.object({
       keywords: z
         .array(z.string())
         .describe(
           "Exact keywords for BM25 search (names, amounts, specific terms)"
         )
         .optional(),
       searchQuery: z
         .string()
         .describe(
           "Natural language query for semantic search (broader concepts)"
         )
         .optional(),
     }),
     execute: async ({ keywords, searchQuery }) => {
       console.log("Keywords:", keywords);
       console.log("Search query:", searchQuery);
 
       const emails = await loadEmails();
       const emailChunks = await chunkEmails(emails);
 
       // Use search algorithm from lesson 2.2
       const bm25Results = keywords
         ? await searchWithBM25(keywords, emailChunks)
         : [];
       const embeddingResults = searchQuery
         ? await searchWithEmbeddings(searchQuery, emailChunks)
         : [];
       const rrfResults = reciprocalRankFusion([
         // Only take the top NUMBER_PASSED_TO_RERANKER results from each search
         bm25Results.slice(0, NUMBER_PASSED_TO_RERANKER),
         embeddingResults.slice(0, NUMBER_PASSED_TO_RERANKER),
       ]);
 
       // Get conversation history without the tool calls
       const conversationHistory = convertToModelMessages(messages).filter(
         (m) => m.role === "user" || m.role === "assistant"
       );
 
       // Rerank results using LLM
       const query = [keywords?.join(" "), searchQuery]
         .filter(Boolean)
         .join(" ");
       const rerankedResults = await rerankEmails(
         rrfResults.slice(0, NUMBER_PASSED_TO_RERANKER),
         query,
         conversationHistory
       );
 
-      // Return full email objects
-      const topEmails = rerankedResults.map((r) => ({
-        id: r.email.id,
-        subject: r.email.subject,
-        body: r.email.chunk,
-        from: r.email.from,
-        to: r.email.to,
-        score: r.score,
-      }));
+      // Return metadata with snippets only
+      const topEmails = rerankedResults.map((r) => {
+        // Get full email to extract threadId
+        const fullEmail = emails.find((e) => e.id === r.email.id);
+        const snippet = r.email.chunk.slice(0, 150).trim() + (r.email.chunk.length > 150 ? "..." : "");
+
+        return {
+          id: r.email.id,
+          threadId: fullEmail?.threadId ?? "",
+          subject: r.email.subject,
+          from: r.email.from,
+          to: r.email.to,
+          timestamp: r.email.timestamp,
+          score: r.score,
+          snippet,
+        };
+      });
 
       console.log("Top emails:", topEmails.length);
 
       return {
         emails: topEmails,
       };
     },
   });
diff --git a/src/app/chat.tsx b/src/app/chat.tsx
index fcea5f6..9e2dc08 100644
--- a/src/app/chat.tsx
+++ b/src/app/chat.tsx
@@ -49,329 +49,384 @@ import { Button } from "@/components/ui/button";
 export const Chat = (props: { chat: DB.Chat | null }) => {
   const [backupChatId, setBackupChatId] = useState(crypto.randomUUID());
   const [input, setInput] = useState("");
   const searchParams = useSearchParams();
   const router = useRouter();
   const chatIdFromSearchParams = searchParams.get("chatId");
 
   const chatIdInUse = chatIdFromSearchParams || backupChatId;
   const { messages, sendMessage, status, regenerate } = useChat<MyMessage>({
     id: chatIdInUse,
     messages: props.chat?.messages || [],
     onData: (message) => {
       if (
         message.type === "data-frontend-action" &&
         message.data === "refresh-sidebar"
       ) {
         router.refresh();
       }
     },
     generateId: () => crypto.randomUUID(),
   });
 
   const ref = useFocusWhenNoChatIdPresent(chatIdFromSearchParams);
 
   const handleSubmit = (message: PromptInputMessage) => {
     const hasText = Boolean(message.text);
     const hasAttachments = Boolean(message.files?.length);
 
     if (!(hasText || hasAttachments)) {
       return;
     }
 
     startTransition(() => {
       sendMessage(
         {
           text: message.text || "Sent with attachments",
           files: message.files,
         },
         {
           body: {
             id: chatIdInUse,
           },
         }
       );
 
       setInput("");
 
       if (!chatIdFromSearchParams) {
         router.push(`/?chatId=${chatIdInUse}`);
         setBackupChatId(crypto.randomUUID());
       }
     });
   };
   return (
     <div className="relative flex-1 items-center flex flex-col min-h-0 w-full">
       <Conversation className="w-full">
         <ConversationContent className="max-w-4xl mx-auto w-full pb-40">
           {messages.map((message) => (
             <div key={message.id}>
               {message.role === "assistant" &&
                 message.parts.filter((part) => part.type === "source-url")
                   .length > 0 && (
                   <Sources>
                     <SourcesTrigger
                       count={
                         message.parts.filter(
                           (part) => part.type === "source-url"
                         ).length
                       }
                     />
                     {message.parts
                       .filter((part) => part.type === "source-url")
                       .map((part, i) => (
                         <SourcesContent key={`${message.id}-${i}`}>
                           <Source
                             key={`${message.id}-${i}`}
                             href={part.url}
                             title={part.url}
                           />
                         </SourcesContent>
                       ))}
                   </Sources>
                 )}
               {message.parts.map((part, i) => {
                 switch (part.type) {
                   case "text":
                     return (
                       <Fragment key={`${message.id}-${i}`}>
                         <Message from={message.role}>
                           <MessageContent>
                             <Response>{part.text}</Response>
                           </MessageContent>
                         </Message>
                         {message.role === "assistant" &&
                           i === messages.length - 1 && (
                             <Actions className="mt-2">
                               <Action
                                 onClick={() => regenerate()}
                                 label="Retry"
                               >
                                 <RefreshCcwIcon className="size-3" />
                               </Action>
                               <Action
                                 onClick={() =>
                                   navigator.clipboard.writeText(part.text)
                                 }
                                 label="Copy"
                               >
                                 <CopyIcon className="size-3" />
                               </Action>
                             </Actions>
                           )}
                       </Fragment>
                     );
                   case "reasoning":
                     return (
                       <Reasoning
                         key={`${message.id}-${i}`}
                         className="w-full"
                         isStreaming={
                           status === "streaming" &&
                           i === message.parts.length - 1 &&
                           message.id === messages.at(-1)?.id
                         }
                       >
                         <ReasoningTrigger />
                         <ReasoningContent>{part.text}</ReasoningContent>
                       </Reasoning>
                     );
                   case "tool-search":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={false}
                       >
                         <ToolHeader
                           title="Search"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Parameters
                                 </h4>
                                 <div className="text-sm">
                                   {part.input.keywords && (
                                     <div>
                                       <span className="font-medium">
                                         Keywords:
                                       </span>{" "}
                                       {part.input.keywords.join(", ")}
                                     </div>
                                   )}
                                   {part.input.searchQuery && (
                                     <div>
                                       <span className="font-medium">
                                         Search Query:
                                       </span>{" "}
                                       {part.input.searchQuery}
                                     </div>
                                   )}
                                 </div>
                               </div>
                             )}
 
                             {/* Email results */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <EmailResultsGrid emails={part.output.emails} />
                               )}
 
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   case "tool-filterEmails":
                     return (
                       <Tool
                         key={`${message.id}-${i}`}
                         className="w-full"
                         defaultOpen={false}
                       >
                         <ToolHeader
                           title="Filter Emails"
                           type={part.type}
                           state={part.state}
                         />
                         <ToolContent>
                           <div className="space-y-4 p-4">
                             {/* Input parameters */}
                             {part.input && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Filters
                                 </h4>
                                 <div className="text-sm space-y-1">
                                   {part.input.from && (
                                     <div>
                                       <span className="font-medium">From:</span>{" "}
                                       {part.input.from}
                                     </div>
                                   )}
                                   {part.input.to && (
                                     <div>
                                       <span className="font-medium">To:</span>{" "}
                                       {part.input.to}
                                     </div>
                                   )}
                                   {part.input.contains && (
                                     <div>
                                       <span className="font-medium">
                                         Contains:
                                       </span>{" "}
                                       {part.input.contains}
                                     </div>
                                   )}
                                   {part.input.before && (
                                     <div>
                                       <span className="font-medium">
                                         Before:
                                       </span>{" "}
                                       {new Date(
                                         part.input.before
                                       ).toLocaleString()}
                                     </div>
                                   )}
                                   {part.input.after && (
                                     <div>
                                       <span className="font-medium">
                                         After:
                                       </span>{" "}
                                       {new Date(
                                         part.input.after
                                       ).toLocaleString()}
                                     </div>
                                   )}
                                   {part.input.limit && (
                                     <div>
                                       <span className="font-medium">
                                         Limit:
                                       </span>{" "}
                                       {part.input.limit}
                                     </div>
                                   )}
                                 </div>
                               </div>
                             )}
 
                             {/* Email results */}
                             {part.state === "output-available" &&
                               part.output && (
                                 <EmailResultsGrid emails={part.output.emails} />
                               )}
 
+                            {/* Error state */}
+                            {part.state === "output-error" && (
+                              <div className="space-y-2">
+                                <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
+                                  Error
+                                </h4>
+                                <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
+                                  {part.errorText}
+                                </div>
+                              </div>
+                            )}
+                          </div>
+                        </ToolContent>
+                      </Tool>
+                    );
+                  case "tool-getEmails":
+                    return (
+                      <Tool
+                        key={`${message.id}-${i}`}
+                        className="w-full"
+                        defaultOpen={true}
+                      >
+                        <ToolHeader
+                          title="Get Emails"
+                          type={part.type}
+                          state={part.state}
+                        />
+                        <ToolContent>
+                          <div className="space-y-4 p-4">
+                            {/* Input parameters */}
+                            {part.input && (
+                              <div className="space-y-2">
+                                <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
+                                  Parameters
+                                </h4>
+                                <div className="text-sm space-y-1">
+                                  {part.input.ids && (
+                                    <div>
+                                      <span className="font-medium">
+                                        Email IDs:
+                                      </span>{" "}
+                                      {part.input.ids.length} email
+                                      {part.input.ids.length !== 1 ? "s" : ""}
+                                    </div>
+                                  )}
+                                </div>
+                              </div>
+                            )}
+
+                            {/* Full email content */}
+                            {part.state === "output-available" &&
+                              part.output && (
+                                <FullEmailDisplay emails={part.output.emails} />
+                              )}
+
                             {/* Error state */}
                             {part.state === "output-error" && (
                               <div className="space-y-2">
                                 <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
                                   Error
                                 </h4>
                                 <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
                                   {part.errorText}
                                 </div>
                               </div>
                             )}
                           </div>
                         </ToolContent>
                       </Tool>
                     );
                   default:
                     return null;
                 }
               })}
             </div>
           ))}
           {status === "submitted" && <Loader />}
         </ConversationContent>
         <ConversationScrollButton />
       </Conversation>
       <div className="absolute bottom-0 flex items-center justify-center w-full sm:px-6 px-5">
         <PromptInput
           onSubmit={handleSubmit}
           className="mb-4"
           globalDrop
           multiple
         >
           <PromptInputBody>
             <PromptInputAttachments>
               {(attachment) => <PromptInputAttachment data={attachment} />}
             </PromptInputAttachments>
             <PromptInputTextarea
               onChange={(e) => setInput(e.target.value)}
               value={input}
               ref={ref}
               autoFocus
             />
           </PromptInputBody>
           <PromptInputToolbar>
             <PromptInputTools>
               <PromptInputActionMenu>
                 <PromptInputActionMenuTrigger />
                 <PromptInputActionMenuContent>
                   <PromptInputActionAddAttachments />
                 </PromptInputActionMenuContent>
               </PromptInputActionMenu>
             </PromptInputTools>
             <PromptInputSubmit disabled={!input && !status} status={status} />
           </PromptInputToolbar>
         </PromptInput>
       </div>
     </div>
   );
 };
@@ -379,50 +434,107 @@ export const Chat = (props: { chat: DB.Chat | null }) => {
 const EmailResultsGrid = ({
   emails,
 }: {
   emails: Array<{
     id: string;
     subject: string;
     from: string;
     to: string | string[];
-    body: string;
+    snippet?: string;
+    timestamp?: string;
   }>;
 }) => {
   const [showAll, setShowAll] = useState(false);
   const displayedEmails = showAll ? emails : emails.slice(0, 8);
   const hasMore = emails.length > 8;
 
   return (
     <div className="space-y-2">
       <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
         Results ({emails.length} {emails.length === 1 ? "email" : "emails"})
       </h4>
       <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
         {displayedEmails.map((email, idx) => (
           <div
             key={idx}
             className="rounded-md border bg-muted/30 p-3 text-sm space-y-1"
           >
             <div className="font-medium">{email.subject}</div>
             <div className="text-muted-foreground text-xs">
               <span className="font-medium">From:</span> {email.from}
             </div>
             <div className="text-muted-foreground text-xs">
               <span className="font-medium">To:</span>{" "}
               {Array.isArray(email.to) ? email.to.join(", ") : email.to}
             </div>
+            {email.snippet && (
+              <div className="text-muted-foreground text-xs mt-2 pt-2 border-t">
+                {email.snippet}
+              </div>
+            )}
           </div>
         ))}
       </div>
       {hasMore && !showAll && (
         <Button
           variant="ghost"
           size="sm"
           onClick={() => setShowAll(true)}
           className="w-full"
         >
           Show more ({emails.length - 8} more)
         </Button>
       )}
     </div>
   );
 };
+
+const FullEmailDisplay = ({
+  emails,
+}: {
+  emails: Array<{
+    id: string;
+    threadId?: string;
+    subject: string;
+    from: string;
+    to: string | string[];
+    timestamp?: string;
+    body: string;
+  }>;
+}) => {
+  return (
+    <div className="space-y-2">
+      <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
+        Full Content ({emails.length} {emails.length === 1 ? "email" : "emails"})
+      </h4>
+      <div className="space-y-4">
+        {emails.map((email, idx) => (
+          <div
+            key={idx}
+            className="rounded-md border bg-muted/30 p-4 text-sm space-y-3"
+          >
+            <div>
+              <div className="font-medium text-base">{email.subject}</div>
+              {email.timestamp && (
+                <div className="text-muted-foreground text-xs mt-1">
+                  {new Date(email.timestamp).toLocaleString()}
+                </div>
+              )}
+            </div>
+            <div className="space-y-1">
+              <div className="text-muted-foreground text-xs">
+                <span className="font-medium">From:</span> {email.from}
+              </div>
+              <div className="text-muted-foreground text-xs">
+                <span className="font-medium">To:</span>{" "}
+                {Array.isArray(email.to) ? email.to.join(", ") : email.to}
+              </div>
+            </div>
+            <div className="pt-3 border-t whitespace-pre-wrap">
+              {email.body}
+            </div>
+          </div>
+        ))}
+      </div>
+    </div>
+  );
+};
