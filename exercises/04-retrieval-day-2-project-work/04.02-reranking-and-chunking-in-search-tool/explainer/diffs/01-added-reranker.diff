commit 0be0b4aa5a507e72b4d4b07c9723ddd1f2c675f4
Author: Matt Pocock <mattpocockvoice@gmail.com>
Date:   Wed Oct 29 14:40:57 2025 +0000

    04.02.01 Added reranker

diff --git a/src/app/api/chat/search-tool.ts b/src/app/api/chat/search-tool.ts
index 6fde40e..78b5a03 100644
--- a/src/app/api/chat/search-tool.ts
+++ b/src/app/api/chat/search-tool.ts
@@ -2,59 +2,69 @@ import {
   chunkEmails,
   loadEmails,
   reciprocalRankFusion,
   searchWithBM25,
   searchWithEmbeddings,
 } from "@/app/search";
+import { rerankEmails } from "@/app/rerank";
 import { tool } from "ai";
 import { z } from "zod";
 
+const NUMBER_PASSED_TO_RERANKER = 30;
+
 export const searchTool = tool({
   description:
     "Search emails using both keyword and semantic search. Returns most relevant emails ranked by reciprocal rank fusion.",
   inputSchema: z.object({
     keywords: z
       .array(z.string())
       .describe(
         "Exact keywords for BM25 search (names, amounts, specific terms)"
       )
       .optional(),
     searchQuery: z
       .string()
       .describe("Natural language query for semantic search (broader concepts)")
       .optional(),
   }),
   execute: async ({ keywords, searchQuery }) => {
     console.log("Keywords:", keywords);
     console.log("Search query:", searchQuery);
 
     const emails = await loadEmails();
     const emailChunks = await chunkEmails(emails);
 
     // Use search algorithm from lesson 2.2
     const bm25Results = keywords
       ? await searchWithBM25(keywords, emailChunks)
       : [];
     const embeddingResults = searchQuery
       ? await searchWithEmbeddings(searchQuery, emailChunks)
       : [];
     const rrfResults = reciprocalRankFusion([
-      bm25Results.slice(0, 30), // Only take the top 30 results from each search
-      embeddingResults.slice(0, 30), // Only take the top 30 results from each search
+      // Only take the top NUMBER_PASSED_TO_RERANKER results from each search
+      bm25Results.slice(0, NUMBER_PASSED_TO_RERANKER),
+      embeddingResults.slice(0, NUMBER_PASSED_TO_RERANKER),
     ]);
 
-    // Return top 10 full email objects
-    const topEmails = rrfResults
-      .slice(0, 10)
-      .filter((r) => r.score > 0) // Only return emails with a score greater than 0
-      .map((r) => ({
-        id: r.email.id,
-        subject: r.email.subject,
-        body: r.email.chunk,
-        score: r.score,
-      }));
+    // Rerank results using LLM
+    const query = [keywords?.join(" "), searchQuery].filter(Boolean).join(" ");
+    const rerankedResults = await rerankEmails(
+      rrfResults.slice(0, NUMBER_PASSED_TO_RERANKER),
+      query
+    );
+
+    // Return full email objects
+    const topEmails = rerankedResults.map((r) => ({
+      id: r.email.id,
+      subject: r.email.subject,
+      body: r.email.chunk,
+      score: r.score,
+    }));
+
+    console.log("Top emails:", topEmails.length);
 
     return {
       emails: topEmails,
     };
   },
 });
diff --git a/src/app/rerank.ts b/src/app/rerank.ts
new file mode 100644
index 0000000..5c5646a
--- /dev/null
+++ b/src/app/rerank.ts
@@ -0,0 +1,69 @@
+import { google } from "@ai-sdk/google";
+import { generateObject } from "ai";
+import { z } from "zod";
+
+type ResultWithEmail = {
+  email: {
+    id: string;
+    subject: string;
+    chunk: string;
+  };
+  score: number;
+};
+
+export const rerankEmails = async (
+  results: ResultWithEmail[],
+  query: string
+): Promise<ResultWithEmail[]> => {
+  const resultsWithId = results.map((result, index) => ({
+    ...result,
+    id: index,
+  }));
+
+  const resultsAsMap = new Map(
+    resultsWithId.map((result) => [result.id, result])
+  );
+  // Call reranker LLM
+  const rerankedResults = await generateObject({
+    model: google("gemini-2.5-flash-lite"),
+    system: `You are a search result reranker. Your job is to analyze a list of email chunks and return only the IDs of the most relevant chunks for answering the user's question.
+
+Given a list of chunks with their IDs and content, you should:
+1. Evaluate how relevant each chunk is to the user's search query
+2. Return only the IDs of the most relevant chunks
+
+You should be selective and only include chunks that are genuinely helpful for answering the question. If a chunk is only tangentially related or not relevant, exclude its ID.
+
+Return the IDs as a simple array of numbers.`,
+    schema: z.object({
+      resultIds: z
+        .array(z.number())
+        .describe("Array of IDs for the most relevant chunks"),
+    }),
+    prompt: `
+      Search query:
+      ${query}
+
+      Available chunks:
+      ${resultsWithId
+        .map((resultWithId) =>
+          [
+            `## ID: ${resultWithId.id}`,
+            `Subject: ${resultWithId.email.subject}`,
+            `<content>`,
+            resultWithId.email.chunk,
+            `</content>`,
+          ].join("\n\n")
+        )
+        .join("\n\n")}
+
+      Return only the IDs of the most relevant chunks for the user's search query.
+    `,
+  });
+
+  console.log("Reranked results:", rerankedResults.object.resultIds);
+
+  return rerankedResults.object.resultIds
+    .map((id) => resultsAsMap.get(id))
+    .filter((r) => r !== undefined);
+};
