commit 5c8b9dc322926682866a334095f32a05d8b6cb7f
Author: Matt Pocock <mattpocockvoice@gmail.com>
Date:   Fri Oct 31 15:01:53 2025 +0000

    04.02.03 Displayed tool calls in frontend

diff --git a/src/app/api/chat/route.ts b/src/app/api/chat/route.ts
index a612f38..594c2a9 100644
--- a/src/app/api/chat/route.ts
+++ b/src/app/api/chat/route.ts
@@ -9,9 +9,10 @@ import { google } from "@ai-sdk/google";
 import {
   convertToModelMessages,
   createUIMessageStream,
   createUIMessageStreamResponse,
+  InferUITools,
   safeValidateUIMessages,
   stepCountIs,
   streamText,
   UIMessage,
 } from "ai";
@@ -24,10 +25,15 @@ export const maxDuration = 30;
 export type MyMessage = UIMessage<
   never,
   {
     "frontend-action": "refresh-sidebar";
-  }
+  },
+  InferUITools<ReturnType<typeof getTools>>
 >;
 
+const getTools = (messages: UIMessage[]) => ({
+  search: searchTool(messages),
+});
+
 export async function POST(req: Request) {
   const body: {
     messages: UIMessage[];
@@ -111,30 +117,28 @@ You are an email assistant that helps users find and understand information from
 <the-ask>
 Here is the user's question. Search their emails first, then provide your answer based on what you find.
 </the-ask>
         `,
-        tools: {
-          search: searchTool(messages),
-        },
+        tools: getTools(messages),
         stopWhen: [stepCountIs(10)],
       });
 
       writer.merge(
         result.toUIMessageStream({
           sendSources: true,
           sendReasoning: true,
         })
       );
 
       await generateTitlePromise;
     },
     generateId: () => crypto.randomUUID(),
     onFinish: async ({ responseMessage }) => {
       await appendToChatMessages(chatId, [responseMessage]);
     },
   });
 
   // send sources and reasoning back to the client
   return createUIMessageStreamResponse({
     stream,
   });
 }
diff --git a/src/app/api/chat/search-tool.ts b/src/app/api/chat/search-tool.ts
index 9d163d8..d12d0c0 100644
--- a/src/app/api/chat/search-tool.ts
+++ b/src/app/api/chat/search-tool.ts
@@ -14,68 +14,70 @@ const NUMBER_PASSED_TO_RERANKER = 30;
 export const searchTool = (messages: UIMessage[]) =>
   tool({
     description:
       "Search emails using both keyword and semantic search. Returns most relevant emails ranked by reciprocal rank fusion.",
     inputSchema: z.object({
       keywords: z
         .array(z.string())
         .describe(
           "Exact keywords for BM25 search (names, amounts, specific terms)"
         )
         .optional(),
       searchQuery: z
         .string()
         .describe(
           "Natural language query for semantic search (broader concepts)"
         )
         .optional(),
     }),
     execute: async ({ keywords, searchQuery }) => {
       console.log("Keywords:", keywords);
       console.log("Search query:", searchQuery);
 
       const emails = await loadEmails();
       const emailChunks = await chunkEmails(emails);
 
       // Use search algorithm from lesson 2.2
       const bm25Results = keywords
         ? await searchWithBM25(keywords, emailChunks)
         : [];
       const embeddingResults = searchQuery
         ? await searchWithEmbeddings(searchQuery, emailChunks)
         : [];
       const rrfResults = reciprocalRankFusion([
         // Only take the top NUMBER_PASSED_TO_RERANKER results from each search
         bm25Results.slice(0, NUMBER_PASSED_TO_RERANKER),
         embeddingResults.slice(0, NUMBER_PASSED_TO_RERANKER),
       ]);
 
       // Get conversation history without the tool calls
       const conversationHistory = convertToModelMessages(messages).filter(
         (m) => m.role === "user" || m.role === "assistant"
       );
 
       // Rerank results using LLM
       const query = [keywords?.join(" "), searchQuery]
         .filter(Boolean)
         .join(" ");
       const rerankedResults = await rerankEmails(
         rrfResults.slice(0, NUMBER_PASSED_TO_RERANKER),
         query,
         conversationHistory
       );
 
       // Return full email objects
       const topEmails = rerankedResults.map((r) => ({
         id: r.email.id,
         subject: r.email.subject,
         body: r.email.chunk,
+        from: r.email.from,
+        to: r.email.to,
         score: r.score,
       }));
 
       console.log("Top emails:", topEmails.length);
 
       return {
         emails: topEmails,
       };
     },
   });
diff --git a/src/app/chat.tsx b/src/app/chat.tsx
index 3b69815..4a0fa08 100644
--- a/src/app/chat.tsx
+++ b/src/app/chat.tsx
@@ -33,8 +33,13 @@ import {
   Source,
   Sources,
   SourcesContent,
   SourcesTrigger,
 } from "@/components/ai-elements/sources";
+import {
+  Tool,
+  ToolContent,
+  ToolHeader,
+} from "@/components/ai-elements/tool";
 import { DB } from "@/lib/persistence-layer";
 import { useChat } from "@ai-sdk/react";
 import { CopyIcon, RefreshCcwIcon } from "lucide-react";
@@ -43,177 +48,294 @@ import { useSearchParams, useRouter } from "next/navigation";
 import { Fragment, startTransition, useState } from "react";
 import type { MyMessage } from "./api/chat/route";
 import { useFocusWhenNoChatIdPresent } from "./use-focus-chat-when-new-chat-button-pressed";
+import { Button } from "@/components/ui/button";
 
 export const Chat = (props: { chat: DB.Chat | null }) => {
   const [backupChatId, setBackupChatId] = useState(crypto.randomUUID());
   const [input, setInput] = useState("");
   const searchParams = useSearchParams();
   const router = useRouter();
   const chatIdFromSearchParams = searchParams.get("chatId");
 
   const chatIdInUse = chatIdFromSearchParams || backupChatId;
   const { messages, sendMessage, status, regenerate } = useChat<MyMessage>({
     id: chatIdInUse,
     messages: props.chat?.messages || [],
     onData: (message) => {
       if (
         message.type === "data-frontend-action" &&
         message.data === "refresh-sidebar"
       ) {
         router.refresh();
       }
     },
     generateId: () => crypto.randomUUID(),
   });
 
   const ref = useFocusWhenNoChatIdPresent(chatIdFromSearchParams);
 
   const handleSubmit = (message: PromptInputMessage) => {
     const hasText = Boolean(message.text);
     const hasAttachments = Boolean(message.files?.length);
 
     if (!(hasText || hasAttachments)) {
       return;
     }
 
     startTransition(() => {
       sendMessage(
         {
           text: message.text || "Sent with attachments",
           files: message.files,
         },
         {
           body: {
             id: chatIdInUse,
           },
         }
       );
 
       setInput("");
 
       if (!chatIdFromSearchParams) {
         router.push(`/?chatId=${chatIdInUse}`);
         setBackupChatId(crypto.randomUUID());
       }
     });
   };
   return (
     <div className="relative flex-1 items-center flex flex-col min-h-0 w-full">
       <Conversation className="w-full">
         <ConversationContent className="max-w-4xl mx-auto w-full pb-40">
           {messages.map((message) => (
             <div key={message.id}>
               {message.role === "assistant" &&
                 message.parts.filter((part) => part.type === "source-url")
                   .length > 0 && (
                   <Sources>
                     <SourcesTrigger
                       count={
                         message.parts.filter(
                           (part) => part.type === "source-url"
                         ).length
                       }
                     />
                     {message.parts
                       .filter((part) => part.type === "source-url")
                       .map((part, i) => (
                         <SourcesContent key={`${message.id}-${i}`}>
                           <Source
                             key={`${message.id}-${i}`}
                             href={part.url}
                             title={part.url}
                           />
                         </SourcesContent>
                       ))}
                   </Sources>
                 )}
               {message.parts.map((part, i) => {
                 switch (part.type) {
                   case "text":
                     return (
                       <Fragment key={`${message.id}-${i}`}>
                         <Message from={message.role}>
                           <MessageContent>
                             <Response>{part.text}</Response>
                           </MessageContent>
                         </Message>
                         {message.role === "assistant" &&
                           i === messages.length - 1 && (
                             <Actions className="mt-2">
                               <Action
                                 onClick={() => regenerate()}
                                 label="Retry"
                               >
                                 <RefreshCcwIcon className="size-3" />
                               </Action>
                               <Action
                                 onClick={() =>
                                   navigator.clipboard.writeText(part.text)
                                 }
                                 label="Copy"
                               >
                                 <CopyIcon className="size-3" />
                               </Action>
                             </Actions>
                           )}
                       </Fragment>
                     );
                   case "reasoning":
                     return (
                       <Reasoning
                         key={`${message.id}-${i}`}
                         className="w-full"
                         isStreaming={
                           status === "streaming" &&
                           i === message.parts.length - 1 &&
                           message.id === messages.at(-1)?.id
                         }
                       >
                         <ReasoningTrigger />
                         <ReasoningContent>{part.text}</ReasoningContent>
                       </Reasoning>
                     );
+                  case "tool-search":
+                    return (
+                      <Tool
+                        key={`${message.id}-${i}`}
+                        className="w-full"
+                        defaultOpen={false}
+                      >
+                        <ToolHeader
+                          title="Search"
+                          type={part.type}
+                          state={part.state}
+                        />
+                        <ToolContent>
+                          <div className="space-y-4 p-4">
+                            {/* Input parameters */}
+                            {part.input && (
+                              <div className="space-y-2">
+                                <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
+                                  Parameters
+                                </h4>
+                                <div className="text-sm">
+                                  {part.input.keywords && (
+                                    <div>
+                                      <span className="font-medium">
+                                        Keywords:
+                                      </span>{" "}
+                                      {part.input.keywords.join(", ")}
+                                    </div>
+                                  )}
+                                  {part.input.searchQuery && (
+                                    <div>
+                                      <span className="font-medium">
+                                        Search Query:
+                                      </span>{" "}
+                                      {part.input.searchQuery}
+                                    </div>
+                                  )}
+                                </div>
+                              </div>
+                            )}
+
+                            {/* Email results */}
+                            {part.state === "output-available" &&
+                              part.output && (
+                                <EmailResultsGrid
+                                  emails={part.output.emails}
+                                />
+                              )}
+
+                            {/* Error state */}
+                            {part.state === "output-error" && (
+                              <div className="space-y-2">
+                                <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
+                                  Error
+                                </h4>
+                                <div className="rounded-md bg-destructive/10 p-3 text-destructive text-sm">
+                                  {part.errorText}
+                                </div>
+                              </div>
+                            )}
+                          </div>
+                        </ToolContent>
+                      </Tool>
+                    );
                   default:
                     return null;
                 }
               })}
             </div>
           ))}
           {status === "submitted" && <Loader />}
         </ConversationContent>
         <ConversationScrollButton />
       </Conversation>
       <div className="absolute bottom-0 flex items-center justify-center w-full sm:px-6 px-5">
         <PromptInput
           onSubmit={handleSubmit}
           className="mb-4"
           globalDrop
           multiple
         >
           <PromptInputBody>
             <PromptInputAttachments>
               {(attachment) => <PromptInputAttachment data={attachment} />}
             </PromptInputAttachments>
             <PromptInputTextarea
               onChange={(e) => setInput(e.target.value)}
               value={input}
               ref={ref}
               autoFocus
             />
           </PromptInputBody>
           <PromptInputToolbar>
             <PromptInputTools>
               <PromptInputActionMenu>
                 <PromptInputActionMenuTrigger />
                 <PromptInputActionMenuContent>
                   <PromptInputActionAddAttachments />
                 </PromptInputActionMenuContent>
               </PromptInputActionMenu>
             </PromptInputTools>
             <PromptInputSubmit disabled={!input && !status} status={status} />
           </PromptInputToolbar>
         </PromptInput>
       </div>
     </div>
   );
 };
+
+const EmailResultsGrid = ({
+  emails,
+}: {
+  emails: Array<{
+    id: string;
+    subject: string;
+    from: string;
+    to: string | string[];
+    body: string;
+    score: number;
+  }>;
+}) => {
+  const [showAll, setShowAll] = useState(false);
+  const displayedEmails = showAll ? emails : emails.slice(0, 8);
+  const hasMore = emails.length > 8;
+
+  return (
+    <div className="space-y-2">
+      <h4 className="font-medium text-muted-foreground text-xs uppercase tracking-wide">
+        Results ({emails.length} {emails.length === 1 ? "email" : "emails"})
+      </h4>
+      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
+        {displayedEmails.map((email, idx) => (
+          <div
+            key={idx}
+            className="rounded-md border bg-muted/30 p-3 text-sm space-y-1"
+          >
+            <div className="font-medium">{email.subject}</div>
+            <div className="text-muted-foreground text-xs">
+              <span className="font-medium">From:</span> {email.from}
+            </div>
+            <div className="text-muted-foreground text-xs">
+              <span className="font-medium">To:</span>{" "}
+              {Array.isArray(email.to) ? email.to.join(", ") : email.to}
+            </div>
+          </div>
+        ))}
+      </div>
+      {hasMore && !showAll && (
+        <Button
+          variant="ghost"
+          size="sm"
+          onClick={() => setShowAll(true)}
+          className="w-full"
+        >
+          Show more ({emails.length - 8} more)
+        </Button>
+      )}
+    </div>
+  );
+};
diff --git a/src/app/rerank.ts b/src/app/rerank.ts
index 49ecca3..316ef85 100644
--- a/src/app/rerank.ts
+++ b/src/app/rerank.ts
@@ -1,13 +1,10 @@
 import { google } from "@ai-sdk/google";
 import { generateObject, ModelMessage } from "ai";
 import { z } from "zod";
+import { EmailChunk } from "./search";
 
 type ResultWithEmail = {
-  email: {
-    id: string;
-    subject: string;
-    chunk: string;
-  };
+  email: EmailChunk;
   score: number;
 };
 
