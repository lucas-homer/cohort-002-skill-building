import { google } from "@ai-sdk/google";
import {
	convertToModelMessages,
	createUIMessageStream,
	createUIMessageStreamResponse,
	hasToolCall,
	type ModelMessage,
	stepCountIs,
	streamText,
	type UIMessage,
} from "ai";
import z from "zod";
import { sendEmail } from "./email-service.ts";
import { findDecisionsToProcess } from "./hitl-processor.ts";

export type ToolRequiringApproval = {
	id: string;
	type: "send-email";
	content: string;
	to: string;
	subject: string;
};

export type ToolApprovalDecision =
	| {
			type: "approve";
	  }
	| {
			type: "reject";
			reason: string;
	  };

export type MyMessage = UIMessage<
	unknown,
	{
		"approval-request": {
			tool: ToolRequiringApproval;
		};
		"approval-decision": {
			// The original tool ID that this decision is for.
			toolId: string;
			decision: ToolApprovalDecision;
		};
	}
>;

const annotateMessageHistory = (messages: MyMessage[]): ModelMessage[] => {
	const modelMessages = convertToModelMessages<MyMessage>(messages, {
		convertDataPart(part) {
			if (part.type === "data-approval-request") {
				return {
					type: "text",
					text: `The assistant requested to send an email: To: ${part.data.tool.to}, Subject: ${part.data.tool.subject}, Content: ${part.data.tool.content}`,
				};
			}
			if (part.type === "data-approval-decision") {
				if (part.data.decision.type === "approve") {
					return {
						type: "text",
						text: "The user approved the tool.",
					};
				}
				return {
					type: "text",
					text: `The user rejected the tool: ${part.data.decision.reason}`,
				};
			}
			return part;
		},
	});

	return modelMessages;
};

export const POST = async (req: Request): Promise<Response> => {
	const body: { messages: MyMessage[] } = await req.json();
	const { messages } = body;

	const mostRecentUserMessage = messages[messages.length - 1];

	// TODO: return a Response of status 400 if there
	// is no most recent user message.
	if (!mostRecentUserMessage) {
		return new Response("No most recent user message", {
			status: 400,
		});
	}

	if (mostRecentUserMessage.role !== "user") {
		return new Response("Most recent message is not from the user", {
			status: 400,
		});
	}

	// NOTE: assistant messages are allowed to be undefined,
	// since at the very start of the conversation we'll only
	// have a user message.
	const mostRecentAssistantMessage = messages.findLast(
		(message) => message.role === "assistant",
	);

	const hitlResult = findDecisionsToProcess({
		mostRecentUserMessage,
		mostRecentAssistantMessage,
	});

	// NOTE: if hitlResult returns a HITLError,
	// we should return a Response with the error message
	if ("status" in hitlResult) {
		return new Response(hitlResult.message, {
			status: hitlResult.status,
		});
	}

	console.dir(hitlResult, { depth: null });

	const annotatedMessageHistory = annotateMessageHistory(messages);

	const stream = createUIMessageStream<MyMessage>({
		execute: async ({ writer }) => {
			const streamTextResponse = streamText({
				model: google("gemini-2.5-flash"),
				system: `
          You are a helpful assistant that can send emails.
          You will be given a diary of the conversation so far.
          The user's name is "John Doe".
        `,
				messages: annotatedMessageHistory,
				tools: {
					sendEmail: {
						description: "Send an email",
						inputSchema: z.object({
							to: z.string(),
							subject: z.string(),
							content: z.string(),
						}),
						execute: ({ to, subject, content }) => {
							writer.write({
								type: "data-approval-request",
								data: {
									tool: {
										id: crypto.randomUUID(),
										type: "send-email",
										to,
										subject,
										content,
									},
								},
							});

							return "Requested to send an email";
						},
					},
				},
				stopWhen: [stepCountIs(10), hasToolCall("sendEmail")],
			});

			writer.merge(streamTextResponse.toUIMessageStream());
		},
	});

	return createUIMessageStreamResponse({
		stream,
	});
};
